# Java, Simple Data Structure Summary
- 프로그래밍을 하면 결국 제일 많이 마주치는 것이 자료구조와 알고리즘이라고 생각한다. 설계와 같이 큰 틀을 보려면 Design Pattern과 다양한 네트워크, OS 지식이 요구되지만,  경험이 적거나 혹은 Cloud를 이용한 간단한 기능들을 모듈로 구현하기 위해서는 자료구주와 알고리즘의 지식이 더 많이 요구된다.
- 이러한 상황을 위해 간단히 DataStructure를 

### 1. List
- 순서를 유지하고 저장
- 중복 저장 가능
	1. ArrayList
		- Index값을 저장하여 Index에 해당 값을 저장한다. 객체가 증가하면 Index도 자동증가된다.
		- 수정/삭제 시 Index값도 변경되어야 하기때문에 메모리 사용이 많아지며, Index값을 저장하여 많은 데이터를 저장하기에는 어려움이 많다.
	2. LinkedList
		- LinkedList는 인접 참조를 링크해서 체인처럼 관리한다. 그러므로, 특정 인덱스의 객체를 제거하면, 앞뒤 링크만 변경된다.
		- 참조된 인접 링크 객체의 값을 갖고 있기때문에, 수정/삭제가 편리하며 적은 메모리 사용으로 많은 데이터를 저장할 수 있다.
	3. Vector 
		- ArrayList와 비슷하지만, 동시접속을 가능하게 만들어준다. 즉, Sync기능을 갖고있다.(Web에서는 서버가 동시접속을 처리해주기 때문에 ArrayList사용을 권장한다.)
		- Vecotr는 1.0때 개발되었으며 현재는 잘 사용하지 않습니다. SynchronizedCollection, SynchronizedList, Map을 이용하는게 성능적으로 더 낫기때문이죠.



### 2. Set 
- 순서를 유지하지 않고 저장
- 중복 저장 불가
	1. HashSet
		- 순서 없이 저장하고, 동일한 객체는 중복 저장하지 않는다.
		- 동일한 객체란, 객체를 저장하기 전에 hashcode() 메소드를 호출해서 해시코드를 얻어내며, 이미 저장되어 있는 객체들의 해시코드와 비교한다. 만약, 동일한 hashcode가 있다면 다시 equals() 메소드로 객체를 비교해서 ture가 나오면 동일한 객체로 판단하고 중복저장을 하지 않는다.
	2. TreeSet
		- TreeSet은 이진트리(binary tree)를 기반으로한 Set Collection이다. 
		- TreeSet은 2개의 자식 노드를 참조하기 위한 2개의 변수로 구성된다. 또한, 객체를 저장하면 자동으로 정렬되는데 부모값과 비교해서 낮은 것은 왼쪽 자식 노드에, 높은 것은 오른쪽 자식 노드에 저장한다.
		- Set 인터페이스 타입 변수에 대입해도 되지만 TreeSet 클래스 타입으로 대입한 이유는 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해서이다.



### 3. Queue
- FIFO(First In First Out) 구조
- Example
	- 들어온 순서대로 처리되기 때문에, 일정한 순서로 Task를 처리하기 위한 ThreadPool에서 많이 사용된다.

### 4. Stack
- LIFO(Last In First Out) 구조


### 5. Map
- Key, Value를 쌍으로 저장
- 키는 중복저장이 되지 않는다.